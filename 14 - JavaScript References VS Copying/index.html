<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>JS Reference VS Copy</title>
</head>

<body>
    <h3>Difference between Reference VS Copy is fundementally important in JS, especially with nested data.</h3>
    <script>
        // start with strings, numbers and booleans
        // Note: When you change the original variable, it will not change the second variable
        let age = 100;
        let age2 = age;
        console.log(age, age2); // 100 100
        age = 200;
        console.log(age, age2); // 200 100

        let name = "Phil";
        let name2 = name;
        console.log(name, name2); // Phil Phil
        name = "PhilCurtis"
        console.log(name, name2); // PhilCurtis Phil
        // If you change the original variable, notice it will not change the second variable


        // Let's say we have an array
        let players = ['player01', 'player02', 'player03', 'player04'];

        // and we want to make a copy of it.
        const team = players;
        console.log("players = ", players); // players =  (4) ["player01", "player02", "player03", "player04"]
        console.log("team = ", team); // team =  (4) ["player01", "player02", "player03", "player04"]

        // You might think we can just do something like this as was done above:
        console.log("Now add this line of code: team[3] = 'player04b' and see what happens to the two variables");
        team[3] = "player04b"

        // however what happens when we update that array?
        console.log("players = ", players); // players =  (4) ["player01", "player02", "player03", "player04b"]
        console.log("team = ", team); // team =  (4) ["player01", "player02", "player03", "player04b"]
        // now here is the problem!
        console.log("The original array has been edited too!  Why? Because it is an array reference, not an array copy so they both point to the same array.");
        // Note: If you change the array in the second variable, notice it will change the original array from the first variable, it will always reference back to the array.

        // So, how do we fix this?
        // Note: Instead of making a reference to the array, make a copy of the array.
        // There are many ways to copy an array.
        players = ['player01', 'player02', 'player03', 'player04'];
        console.log("players = ", players ");
                // 1) one way
                const team2 = players.slice(); // Slice with nothing passed in will make a copy the array
                console.log("players =", players); console.log("players.slice() = ", players.slice()); console.log("players.slice(2,3) = ", players.slice(2, 3)); // normal use of slice

                // 2) or create a new array and concat the old one in
                const team3 = [].concat(players);

                // 3) or use the new ES6 Spread
                const team4 = [...players]; // spread will take every item out of the iterable (array), and put it into the container (a new array)
                team[3] = 'player04c-ES6'
                console.log("team4 = ", team4);


                // 4) 
                const team5 = Array.from(players)

                // now when we update it, the original one isn't changed

                // 5:55
                // The same thing goes for objects, let's say we have a person object

                // with Objects
                // const person = {
                //     name: StephTresidder,
                //     age: 32
                // }

                // and think we make a copy:

                // how do we take a copy instead?

                // We will hopefully soon see the object ...spread

                // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
    </script>

</body>

</html>